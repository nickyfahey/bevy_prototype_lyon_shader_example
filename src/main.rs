use bevy::{
    prelude::*,
    reflect::TypePath,
    render::{
        mesh::{MeshVertexAttribute, VertexAttributeValues},
        render_resource::{AsBindGroup, ShaderRef, VertexFormat},
    },
    sprite::{Material2d, Material2dPlugin},
};
use bevy_prototype_lyon::prelude::*;
use bevy_prototype_lyon::shapes::Circle;

/// This example uses a shader source file from the assets subdirectory
const SHADER_ASSET_PATH: &str = "shaders/circle_shader.wgsl";
const CUSTOM_ATTRIBUTE: MeshVertexAttribute =
    MeshVertexAttribute::new("CustomAttribute", 988540917, VertexFormat::Float32);

fn main() {
    App::new()
        .add_plugins((
            DefaultPlugins,
            Material2dPlugin::<CustomMaterial>::default(),
            MeshPickingPlugin,
            ShapePlugin,
        ))
        .add_systems(Startup, setup)
        .add_systems(
            PostUpdate,
            set_uvs.after(bevy_prototype_lyon::plugin::BuildShapes),
        )
        .run();
}

// Setup a simple 2d scene
fn setup(mut commands: Commands, mut materials: ResMut<Assets<CustomMaterial>>) {
    commands.spawn(Camera2d);

    // Avoid using the ShapeBundle so we are not forced to include a ColorMaterial.
    commands
        .spawn((
            GeometryBuilder::build_as(&Circle {
                radius: 100.,
                center: Vec2::ZERO,
            }),
            Stroke::new(LinearRgba::GREEN, 50.),
            Fill::color(Color::WHITE),
            Mesh2d::default(),
            MeshMaterial2d(materials.add(CustomMaterial {
                replace_color: LinearRgba::GREEN,
                clip_radius: 0.7,
                clip_center: Vec2::new(-0., -0.),
            })),
        ))
        .observe(on_over)
        .observe(on_out);
}

/// Set the UVs for the mesh generated by `bevy_prototype_lyon` so we can use them in out custom texture.
fn set_uvs(mut meshes: ResMut<Assets<Mesh>>, mesh2ds: Query<&Mesh2d, Added<Mesh2d>>) {
    let mesh_handle = mesh2ds.get_single();

    if let Ok(mesh_handle) = mesh_handle {
        let mesh = meshes.get_mut(mesh_handle).unwrap();

        let positions = mesh.attribute(Mesh::ATTRIBUTE_POSITION).unwrap();
        let VertexAttributeValues::Float32x3(positions) = positions else {
            panic!("Unexpected vertex format, expected Float32x3.");
        };

        let min: Vec2 = positions.iter().fold(Vec2::MAX, |acc, [x, y, _]| {
            Vec2::new(acc.x.min(*x), acc.y.min(*y))
        });

        let max: Vec2 = positions.iter().fold(Vec2::MIN, |acc, [x, y, _]| {
            Vec2::new(acc.x.max(*x), acc.y.max(*y))
        });

        let size = positions.len();

        // UVs go from [0,0] in the top left to [1,1] in the bottom right.
        let uvs: Vec<_> = positions
            .iter()
            .map(|[x, y, _]| {
                let x_range = max.x - min.y;
                let y_range = max.y - min.y;
                let uv_x = (x - min.x) / x_range;
                let uv_y = 1. - ((y - min.y) / y_range);
                [uv_x, uv_y]
            })
            .collect();

        let mut customs = Vec::with_capacity(size);
        for [x, y, z] in positions {
            customs.push(x + y + z);
        }

        mesh.insert_attribute(CUSTOM_ATTRIBUTE, customs);
        mesh.insert_attribute(Mesh::ATTRIBUTE_UV_0, uvs);
    }
}

/// This observer shows how to change a shader property at run time.
fn on_over(
    _trigger: Trigger<Pointer<Over>>,
    q: Query<(&MeshMaterial2d<CustomMaterial>, &Transform)>,
    mut materials: ResMut<Assets<CustomMaterial>>,
) {
    let (mesh_mat, _trans) = q.single();
    let mat = materials.get_mut(mesh_mat).unwrap();
    mat.clip_radius = 1.0;
}

fn on_out(
    _trigger: Trigger<Pointer<Out>>,
    q: Query<(&MeshMaterial2d<CustomMaterial>, &Transform)>,
    mut materials: ResMut<Assets<CustomMaterial>>,
) {
    let (mesh_mat, _trans) = q.single();
    let mat = materials.get_mut(mesh_mat).unwrap();
    mat.clip_radius = 0.7;
}

// This is the struct that will be passed to your shader
#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
struct CustomMaterial {
    #[uniform(0)]
    replace_color: LinearRgba,
    #[uniform(1)]
    clip_radius: f32,
    #[uniform(2)]
    clip_center: Vec2,
}

/// The Material2d trait is very configurable, but comes with sensible defaults for all methods.
/// You only need to implement functions for features that need non-default behavior. See the Material2d api docs for details!
impl Material2d for CustomMaterial {
    fn fragment_shader() -> ShaderRef {
        SHADER_ASSET_PATH.into()
    }
}
